<!DOCTYPE html>
<html lang="vi" data-theme="light" class="h-screen">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="static/favicon.ico" type="image/x-icon" />

    <title>Giao Ti·∫øp Ti·∫øng Anh - English</title>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Global Configuration -->
    <script src="config.js"></script>
    <style>
        body {
            height: 100vh;
            overflow: hidden;
        }

        .chat-container {
            height: calc(100vh - 400px);
            overflow-y: auto;
            padding-bottom: 1rem;
            padding-right: 20px;
            padding-left: 20px;
        }

        .session-list {
            height: calc(100vh - 64px);
            overflow-y: auto;
            border-right: 1px solid #e5e7eb;
        }

        .session-item {
            padding: 1rem;
            border-bottom: 1px solid #e5e7eb;
            cursor: pointer;
            transition: background-color 0.2s;
            position: relative;
        }

        .session-item:hover {
            background-color: #f3f4f6;
        }

        .session-item.active {
            background-color: #e5e7eb;
        }

        .session-item .time {
            font-size: 0.75rem;
            color: #6b7280;
        }

        .session-item .preview {
            font-size: 0.875rem;
            color: #374151;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .session-item .delete-btn {
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            opacity: 0;
            transition: opacity 0.2s;
            color: #ef4444;
            padding: 0.25rem;
            border-radius: 0.25rem;
        }

        .session-item:hover .delete-btn {
            opacity: 1;
        }

        .session-item .delete-btn:hover {
            background-color: #fee2e2;
        }

        .main-content {
            flex: 1;
            overflow: hidden;
        }

        .recording {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
            }
        }

        .card-body {
            padding-bottom: 2rem;
            display: flex;
            flex-direction: column;
        }

        .chat-bubble {
            cursor: pointer;
        }

        .chat-bubble span {
            display: inline-block;
            padding: 2px 3px;
            transition: text-decoration 0.2s;
            cursor: pointer;
        }

        .chat-bubble span:hover {
            text-decoration: underline;
        }

        .chat-bubble span.clicked {
            background-color: rgba(59, 130, 246, 0.2);
        }

        .translation-tooltip {
            position: fixed;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 1001;
            max-width: 300px;
        }

        .translation-tooltip .original {
            color: #6b7280;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .translation-tooltip .translated {
            color: #1f2937;
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 4px;
        }

        .translation-tooltip .ipa {
            color: #4b5563;
            font-size: 14px;
            font-style: italic;
        }

        .speaker-icon {
            cursor: pointer;
            transition: transform 0.2s;
        }

        .speaker-icon:hover {
            transform: scale(1.1);
        }

        .speaker-icon.playing {
            animation: pulse 1s infinite;
        }

        /* Add styles for vocabulary sidebar */
        .vocabulary-sidebar {
            right: 1rem;
            top: 5rem;
            width: 16rem;
            z-index: 40;
        }



        .vocabulary-container {
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .vocabulary-header {
            padding: 1rem;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .vocabulary-content {
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            overflow-y: auto;
        }

        .vocabulary-input {
            flex: 1;
        }

        .vocabulary-output {
            flex: 1;
        }

        .vocabulary-textarea {
            resize: none;
            width: 100%;
            font-size: 0.875rem;
            min-height: 100px;
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
            background-color: white;
            transition: border-color 0.2s;
        }

        .vocabulary-textarea:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        }

        .vocabulary-pronunciation {}
    </style>
</head>

<body class="flex flex-col">
    <!-- Navbar -->
    <div class="navbar bg-base-100 shadow-lg sticky top-0 z-50 flex justify-between">
        <div class="">
            <a href="index.html" class="btn btn-ghost text-xl">English Learning</a>
        </div>

        <div class="gap-2">
            <div class="">
                <ul class="menu menu-horizontal px-1 mx-auto flex gap-4">
                    <!-- <li><a href="giao-tiep.html" class="active">Giao Ti·∫øp</a></li> -->
                    <!-- <li><a href="tu-vung.html">T·ª´ V·ª±ng</a></li> -->
                </ul>
            </div>
            <div class="dropdown dropdown-end">
                <div tabindex="0" role="button" class="btn btn-ghost btn-circle avatar">
                    <div class="w-10 rounded-full">
                        <img id="userAvatar" alt="User Avatar" />
                    </div>
                </div>
                <ul tabindex="0"
                    class="mt-3 z-[1] p-2 shadow menu menu-sm dropdown-content bg-base-100 rounded-box w-52">
                    <li><a id="logoutButton">ƒêƒÉng xu·∫•t</a></li>

                </ul>
            </div>
        </div>
    </div>

    <!-- Chat Container -->
    <div class="flex-1 container mx-auto px-4 py-4 flex gap-4">
        <!-- Session History -->
        <div class="w-64 bg-base-100 shadow-xl rounded-lg">
            <div class="p-4 border-b flex justify-between items-center">
                <h3 class="font-semibold">L·ªãch s·ª≠ h·ªôi tho·∫°i</h3>
                <button id="newSessionButton" class="btn btn-circle btn-sm btn-primary">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                        stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
                    </svg>
                </button>
            </div>
            <div class="session-list" id="sessionList">
                <!-- Sessions will be added here dynamically -->
            </div>
        </div>

        <!-- Main Chat Area -->
        <div class="main-content">
            <div class="card bg-base-100 shadow-xl h-full">
                <div class="card-body">
                    <h2 class="card-title text-center mb-4 flex justify-between items-center">
                        <div>Luy·ªán Giao Ti·∫øp Ti·∫øng Anh</div>
                        <label class="label">
                            <div>Ch·∫ø ƒë·ªô t·ª± ƒë·ªông</div>
                            <input id="autoMode" type="checkbox" class="toggle toggle-primary ml-2" />
                        </label>
                    </h2>

                    <!-- Chat Messages -->
                    <div class="chat-container">
                        <div class="chat chat-start">

                        </div>
                    </div>

                    <!-- Input and Send Button -->
                    <div id="inputContainer" class="hidden input-container">
                        <div class="flex gap-2">
                            <input type="text" id="messageInput" class="input input-bordered flex-1"
                                placeholder="Ch·ªânh s·ª≠a vƒÉn b·∫£n c·ªßa b·∫°n...">
                            <button id="sendButton" class="btn btn-primary">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                                    stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
                                </svg>
                            </button>
                        </div>
                    </div>

                    <!-- Recording Button -->
                    <div class="flex justify-center items-center mt-4">
                        <button id="recordButton" class="btn btn-circle btn-lg btn-primary">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                                stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
                            </svg>
                        </button>
                    </div>

                    <!-- Status Message -->
                    <div id="statusMessage" class="text-center mt-2 text-sm text-gray-500"></div>
                </div>
            </div>
        </div>

        <!-- Vocabulary Sidebar -->
        <div class="vocabulary-sidebar">
            <div class="vocabulary-container">
                <div class="vocabulary-header">
                    <h3 class="font-semibold">T·ª´ V·ª±ng</h3>
                    <div class="flex gap-2">
                        <button id="switchLanguage" class="btn btn-ghost btn-sm" title="ƒê·ªïi ng√¥n ng·ªØ">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24"
                                stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4" />
                            </svg>
                        </button>
                    </div>
                </div>
                <div class="vocabulary-content">
                    <!-- Input -->
                    <div class="vocabulary-input">
                        <div class="flex justify-between items-center mb-2">
                            <div id="sourceLabel" class="text-sm font-medium text-gray-500">Ti·∫øng Vi·ªát</div>
                            <button id="speakSourceBtn" class="btn btn-ghost btn-sm" title="Ph√°t √¢m">
                                <svg xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 24 24"
                                    fill="currentColor" class="h-5 w-5">
                                    <path
                                        d="M3 10v4h4l5 5V5l-5 5H3zm13.5 2c0-1.77-1.02-3.29-2.5-4.03v8.06c1.48-.74 2.5-2.26 2.5-4.03zm2.5 0c0 2.53-1.61 4.71-4 5.43v2.07c3.31-.86 5.5-3.85 5.5-7.5s-2.19-6.64-5.5-7.5v2.07c2.39.72 4 2.9 4 5.43z" />
                                </svg>
                            </button>
                        </div>
                        <textarea id="sourceText" class="vocabulary-textarea"
                            placeholder="Nh·∫≠p vƒÉn b·∫£n c·∫ßn d·ªãch..."></textarea>
                    </div>

                    <!-- Translation -->
                    <div class="vocabulary-output">
                        <div class="flex justify-between items-center mb-2">
                            <div id="targetLabel" class="text-sm font-medium text-gray-500">Ti·∫øng Anh</div>
                            <button id="speakTargetBtn" class="btn btn-ghost btn-sm" title="Ph√°t √¢m">
                                <svg xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 24 24"
                                    fill="currentColor" class="h-5 w-5">
                                    <path
                                        d="M3 10v4h4l5 5V5l-5 5H3zm13.5 2c0-1.77-1.02-3.29-2.5-4.03v8.06c1.48-.74 2.5-2.26 2.5-4.03zm2.5 0c0 2.53-1.61 4.71-4 5.43v2.07c3.31-.86 5.5-3.85 5.5-7.5s-2.19-6.64-5.5-7.5v2.07c2.39.72 4 2.9 4 5.43z" />
                                </svg>
                            </button>
                        </div>
                        <div id="targetText" class="vocabulary-textarea bg-base-200"></div>
                        <div id="pronunciation" class="vocabulary-pronunciation"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>



    <script>
        // Add this at the beginning of the script section
        // Check login status and load user data
        document.addEventListener('DOMContentLoaded', () => {
            const userData = localStorage.getItem('userData');
            if (!userData) {
                window.location.href = 'index.html';
                return;
            }

            const userDataObj = JSON.parse(userData);
            const userAvatar = document.getElementById('userAvatar');
            if (userDataObj.userInfo && userDataObj.userInfo.user && userDataObj.userInfo.user.picture) {
                userAvatar.src = userDataObj.userInfo.user.picture;
            }

            // Add logout functionality
            document.getElementById('logoutButton').addEventListener('click', () => {
                localStorage.removeItem('userData');
                localStorage.removeItem('currentSessionId');
                window.location.href = 'index.html';
            });

            // Add delete messages functionality
            const deleteMessagesBtn = document.getElementById('deleteMessages');
            if (deleteMessagesBtn) {
                deleteMessagesBtn.addEventListener('click', async () => {
                    try {
                        const userData = localStorage.getItem('userData');
                        if (!userData) {
                            window.location.href = 'index.html';
                            return;
                        }
                        const userDataObj = JSON.parse(userData);
                        const token = userDataObj.token;

                        const response = await fetch(`${CONFIG.SERVER_DOMAIN}/messages`, {
                            method: 'DELETE',
                            headers: {
                                'Authorization': `Bearer ${token}`,
                                'Content-Type': 'application/json'
                            }
                        });

                        if (response.ok) {
                            // Reload the page to show empty chat
                            window.location.reload();
                        } else {
                            throw new Error('Failed to delete messages');
                        }
                    } catch (error) {
                        console.error('Error deleting messages:', error);
                        statusMessage.textContent = 'C√≥ l·ªói x·∫£y ra khi x√≥a h·ªôi tho·∫°i. Vui l√≤ng th·ª≠ l·∫°i.';
                    }
                });
            }
        });

        let mediaRecorder;
        let audioChunks = [];
        let recordingTimeout;
        const MAX_RECORDING_TIME = 60000; // 60 seconds
        const MIN_AUDIO_SIZE = 1024; // 1KB
        const MAX_AUDIO_SIZE = 10 * 1024 * 1024; // 10MB
        const recordButton = document.getElementById('recordButton');
        const statusMessage = document.getElementById('statusMessage');
        const chatContainer = document.querySelector('.chat-container');
        const inputContainer = document.getElementById('inputContainer');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        let isRecording = false;
        let currentTranscribedText = '';
        let autoSendTimer = null;
        let hasUserInteracted = false;

        let currentAudio = null;

        // Add these variables at the beginning of the script
        let currentSessionId = null;
        const sessionList = document.getElementById('sessionList');

        // Function to format date
        function formatDate(dateString) {
            const date = new Date(dateString);
            return date.toLocaleString('vi-VN', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        // Function to add session to the list
        function addSessionToList(session) {
            const sessionDiv = document.createElement('div');
            sessionDiv.className = `session-item ${session.id === currentSessionId ? 'active' : ''}`;
            sessionDiv.dataset.sessionId = session.id;

            sessionDiv.innerHTML = `
                <div class="time">${formatDate(session.created_at)}</div>
                <div class="preview">${session.title || 'Ch∆∞a c√≥ ti√™u ƒë·ªÅ'}</div>
                <button class="delete-btn" title="X√≥a h·ªôi tho·∫°i">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                    </svg>
                </button>
            `;

            // Add click event for session selection
            sessionDiv.addEventListener('click', (e) => {
                // Don't trigger session load if clicking delete button
                if (!e.target.closest('.delete-btn')) {
                    loadSession(session.id);
                }
            });

            // Add click event for delete button
            const deleteBtn = sessionDiv.querySelector('.delete-btn');
            deleteBtn.addEventListener('click', async (e) => {
                e.stopPropagation(); // Prevent session selection
                if (confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a h·ªôi tho·∫°i n√†y?')) {
                    await deleteSession(session.id);
                }
            });

            sessionList.appendChild(sessionDiv);
        }

        // Function to load a specific session
        async function loadSession(sessionId) {
            try {
                const userData = localStorage.getItem('userData');
                if (!userData) {
                    window.location.href = 'index.html';
                    return;
                }
                const userDataObj = JSON.parse(userData);
                const token = userDataObj.token;

                const response = await fetch(`${CONFIG.SERVER_DOMAIN}/messages/${sessionId}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to load session');
                }

                const data = await response.json();
                setCurrentSessionId(sessionId);

                // Update active session in the list
                document.querySelectorAll('.session-item').forEach(item => {
                    item.classList.toggle('active', item.dataset.sessionId === sessionId);
                });

                // Clear and reload messages
                chatContainer.innerHTML = '';
                data.messages.forEach(message => {
                    if (message.sender === 'assistant') {
                        addAIMessage(message.content);
                    } else {
                        addUserMessage(message.content);
                    }
                });
            } catch (error) {
                console.error('Error loading session:', error);
                statusMessage.textContent = 'C√≥ l·ªói x·∫£y ra khi t·∫£i h·ªôi tho·∫°i. Vui l√≤ng th·ª≠ l·∫°i.';
            }
        }

        // H√†m x·ª≠ l√Ω d·ªãch v√† hi·ªÉn th·ªã k·∫øt qu·∫£
        async function handleTranslation(text, position) {
            if (!text) return;

            // X√≥a tooltip c≈© n·∫øu c√≥
            const oldTooltip = document.querySelector('.translation-tooltip');
            if (oldTooltip) {
                oldTooltip.remove();
            }

            // T·∫°o tooltip loading
            const tooltip = document.createElement('div');
            tooltip.className = 'translation-tooltip';
            tooltip.innerHTML = `
                <div class="original">${text}</div>
                <div class="translated">ƒêang d·ªãch...</div>
            `;
            tooltip.style.top = `${position.bottom + window.scrollY + 5}px`;
            tooltip.style.left = `${position.left + window.scrollX}px`;
            document.body.appendChild(tooltip);

            try {
                // L·∫•y th√¥ng tin phi√™n √¢m t·ª´ API dictionary v·ªõi timeout
                // const pronunciationPromise = fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${text}`, {
                //     signal: AbortSignal.timeout(5000) // 5 gi√¢y timeout
                // });
                // let phonetic = '';
                // try {
                //     const pronunciationResponse = await pronunciationPromise;
                //     if (pronunciationResponse.ok) {
                //         const pronunciationData = await pronunciationResponse.json();
                //         if (Array.isArray(pronunciationData) && pronunciationData.length > 0) {
                //             phonetic = pronunciationData[0].phonetic || pronunciationData[0].phonetics[0]?.text || '';
                //         }
                //     }
                // } catch (error) {
                //     console.warn('Kh√¥ng th·ªÉ l·∫•y phi√™n √¢m:', error);
                // }

                // L·∫•y b·∫£n d·ªãch v·ªõi retry
                let translatedText = '';
                let retryCount = 0;
                const maxRetries = 3;

                while (retryCount < maxRetries) {
                    try {
                        const response = await fetch(`${CONFIG.SERVER_DOMAIN}/translate`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                text: text,
                                direction: 'en_to_vi'
                            }),
                            signal: AbortSignal.timeout(5000) // 5 gi√¢y timeout
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }

                        const data = await response.json();
                        translatedText = data.translated_text;
                        ipa = data.ipa || '';
                        break;
                    } catch (error) {
                        retryCount++;
                        if (retryCount === maxRetries) {
                            throw error;
                        }
                        await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                    }
                }

                // C·∫≠p nh·∫≠t tooltip v·ªõi k·∫øt qu·∫£
                tooltip.innerHTML = `
                    <div class="original">${text}</div>
                    <div class="translated">${translatedText}</div>
                    ${ipa ? `<div class="ipa">${ipa}</div>` : ''}
                `;

                // Ki·ªÉm tra v√† ƒëi·ªÅu ch·ªânh v·ªã tr√≠ tooltip n·∫øu c·∫ßn
                const tooltipRect = tooltip.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;

                if (tooltipRect.right > viewportWidth) {
                    tooltip.style.left = `${viewportWidth - tooltipRect.width - 10}px`;
                }
                if (tooltipRect.bottom > viewportHeight) {
                    tooltip.style.top = `${position.top - tooltipRect.height - 5}px`;
                }

                // Th√™m animation
                tooltip.style.opacity = '0';
                tooltip.style.transform = 'translateY(10px)';
                tooltip.style.transition = 'opacity 0.3s ease, transform 0.3s ease';

                requestAnimationFrame(() => {
                    tooltip.style.opacity = '1';
                    tooltip.style.transform = 'translateY(0)';
                });

            } catch (error) {
                console.error('L·ªói khi d·ªãch:', error);
                tooltip.innerHTML = `
                    <div class="original">${text}</div>
                    <div class="translated error">Kh√¥ng th·ªÉ d·ªãch. Vui l√≤ng th·ª≠ l·∫°i.</div>
                `;
            }
        }

        // H√†m th√™m tin nh·∫Øn c·ªßa AI
        function addAIMessage(message) {
            const chatDiv = document.createElement('div');
            chatDiv.className = 'chat chat-start';
            const messageWords = message.split(' ');
            const formattedMessage = messageWords.map(word => `<span>${word}</span>`).join(' ');
            chatDiv.innerHTML = `
                <div class="chat-bubble flex-wrap max-w-[500px] flex items-center">
                    <button class="speaker-icon" title="Ph√°t √¢m thanh">
                        <svg class="w-6 h-6 text-gray-800 text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24">
                        <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.5 8.43A4.985 4.985 0 0 1 17 12a4.984 4.984 0 0 1-1.43 3.5m2.794 2.864A8.972 8.972 0 0 0 21 12a8.972 8.972 0 0 0-2.636-6.364M12 6.135v11.73a1 1 0 0 1-1.64.768L6 15H4a1 1 0 0 1-1-1v-4a1 1 0 0 1 1-1h2l4.36-3.633a1 1 0 0 1 1.64.768Z"/>
                        </svg>
                    </button>
                    ${formattedMessage}
                </div>
            `;

            // Th√™m s·ª± ki·ªán click cho n√∫t ph√°t √¢m
            const speakerButton = chatDiv.querySelector('.speaker-icon');
            speakerButton.addEventListener('click', () => {
                speakerButton.classList.toggle('playing');
                playTextToSpeech(message, speakerButton);
            });

            // Th√™m s·ª± ki·ªán click cho t·ª´ng t·ª´
            const wordSpans = chatDiv.querySelectorAll('span');
            wordSpans.forEach(word => {
                word.addEventListener('click', (e) => {
                    // X√≥a highlight c·ªßa c√°c t·ª´ kh√°c
                    document.querySelectorAll('.chat-bubble span.clicked').forEach(w => {
                        w.classList.remove('clicked');
                    });

                    // Highlight t·ª´ ƒë∆∞·ª£c click
                    word.classList.add('clicked');

                    // X·ª≠ l√Ω d·ªãch
                    handleTranslation(word.textContent, word.getBoundingClientRect());
                });
            });

            chatContainer.appendChild(chatDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        // H√†m th√™m tin nh·∫Øn c·ªßa ng∆∞·ªùi d√πng
        function addUserMessage(message) {
            const chatDiv = document.createElement('div');
            chatDiv.className = 'chat chat-end';
            const messageWords = message.split(' ');
            const formattedMessage = messageWords.map(word => `<span>${word}</span>`).join(' ');
            chatDiv.innerHTML = `
                <div class="chat-bubble chat-bubble-primary">${formattedMessage}</div>
            `;

            // Th√™m s·ª± ki·ªán click cho t·ª´ng t·ª´
            const wordSpans = chatDiv.querySelectorAll('span');
            wordSpans.forEach(word => {
                word.addEventListener('click', (e) => {
                    // X√≥a highlight c·ªßa c√°c t·ª´ kh√°c
                    document.querySelectorAll('.chat-bubble span.clicked').forEach(w => {
                        w.classList.remove('clicked');
                    });

                    // Highlight t·ª´ ƒë∆∞·ª£c click
                    word.classList.add('clicked');

                    // X·ª≠ l√Ω d·ªãch
                    handleTranslation(word.textContent, word.getBoundingClientRect());
                });
            });

            chatContainer.appendChild(chatDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        // Modify the fetchChatHistory function to handle sessions
        async function fetchChatHistory() {
            try {
                const userData = localStorage.getItem('userData');
                if (!userData) {
                    window.location.href = 'index.html';
                    return;
                }
                const userDataObj = JSON.parse(userData);
                const token = userDataObj.token;

                const response = await fetch(`${CONFIG.SERVER_DOMAIN}/sessions`, {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to fetch sessions');
                }

                const sessions = await response.json();

                // Clear session list
                sessionList.innerHTML = '';

                // Add sessions to the list
                sessions.forEach(session => {
                    addSessionToList(session);
                });

                // Check if we have a current session ID (from page reload)
                if (currentSessionId) {
                    // Reload the current session
                    loadSession(currentSessionId);
                } else {
                    // If no sessions at all, show new session screen
                    chatContainer.innerHTML = '';
                    addAIMessage("Xin ch√†o! T√¥i l√† tr·ª£ l√Ω AI c·ªßa b·∫°n. H√£y b·∫Øt ƒë·∫ßu luy·ªán t·∫≠p giao ti·∫øp ti·∫øng Anh!");
                }
            } catch (error) {
                console.error('L·ªói khi l·∫•y l·ªãch s·ª≠ chat:', error);
                statusMessage.textContent = 'Kh√¥ng th·ªÉ t·∫£i l·ªãch s·ª≠ chat. Vui l√≤ng th·ª≠ l·∫°i sau.';
            }
        }

        // Add this after the fetchChatHistory function
        // Save current session ID to localStorage when it changes
        function setCurrentSessionId(sessionId) {
            currentSessionId = sessionId;
            localStorage.setItem('currentSessionId', sessionId);
        }


        // Audio
        let stream;
        let analyserIntervalId;
        var silenceStart = null;
        var isFirstRecording = true;
        var recordingStarted = false;
        // TƒÉng l√™n n·∫øu b·ªã ·ªìn
        var silenceThreshold = 0.1;
        var maxSilenceDuration = 5000;
        var checkInterval = 100;
        function getVolume() {
            analyser.getByteTimeDomainData(dataArray);
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                let value = (dataArray[i] - 128) / 128;
                sum += value * value;
            }
            // console.log("Volume data:", Math.sqrt(sum / dataArray.length));
            return Math.sqrt(sum / dataArray.length);
        }

        async function startAnalyser() {
            if(!stream) {
                // N·∫øu ƒë√£ c√≥ stream, kh√¥ng c·∫ßn y√™u c·∫ßu l·∫°i
                stream= await navigator.mediaDevices.getUserMedia({
                    audio: true
                });
            }

            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            sourceNode = audioContext.createMediaStreamSource(stream);
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            dataArray = new Uint8Array(analyser.fftSize);
            sourceNode.connect(analyser);

            analyserIntervalId = setInterval(() => {
                const volume = getVolume();

                if (volume > silenceThreshold && !isRecording) {
                    console.log("üéôÔ∏è Ph√°t hi·ªán √¢m thanh");
                    isFirstRecording = false;
                    startRecord();
                    silenceStart = null;
                } else {
                    if(isFirstRecording){
                        return;
                    }
                    if (!silenceStart) {
                        silenceStart = Date.now();
                    } else if (Date.now() - silenceStart > maxSilenceDuration) {
                        console.log("üõë Y√™n l·∫∑ng qu√° 3s - d·ª´ng ghi");
                        isFirstRecording = true;
                        stopRecording();
                        stopAnalyser();
                    }
                }
            }, checkInterval);
        }


        function stopAnalyser() {
            if (analyserIntervalId) clearInterval(analyserIntervalId);
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
        }

        // Y√™u c·∫ßu quy·ªÅn truy c·∫≠p microphone
        async function setupRecording() {
            try {
                
                if(!stream) {
                    // N·∫øu ƒë√£ c√≥ stream, kh√¥ng c·∫ßn y√™u c·∫ßu l·∫°i
                    stream= await navigator.mediaDevices.getUserMedia({
                        audio: true
                    });
                }
                // X·ª≠ l√Ω khi stream b·ªã ng·∫Øt
                stream.getAudioTracks().forEach(track => {
                    track.onended = () => {
                        if (isRecording) {
                            stopRecording();
                        }
                        statusMessage.textContent = 'Microphone ƒë√£ b·ªã ng·∫Øt k·∫øt n·ªëi. Vui l√≤ng th·ª≠ l·∫°i.';
                    };
                });

                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus'
                });

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = async () => {
                    try {
                        if (audioChunks.length === 0) {
                            throw new Error('Kh√¥ng c√≥ d·ªØ li·ªáu √¢m thanh');
                        }

                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        // Ki·ªÉm tra k√≠ch th∆∞·ªõc audio
                        if (audioBlob.size < MIN_AUDIO_SIZE) {
                            throw new Error('√Çm thanh qu√° ng·∫Øn');
                        }
                        if (audioBlob.size > MAX_AUDIO_SIZE) {
                            throw new Error('√Çm thanh qu√° d√†i');
                        }

                        statusMessage.textContent = 'ƒêang chuy·ªÉn ƒë·ªïi √¢m thanh th√†nh vƒÉn b·∫£n...';

                        const formData = new FormData();
                        formData.append('audio', audioBlob);

                        const response = await fetch(`${CONFIG.SERVER_DOMAIN}/speech`, {
                            method: 'POST',
                            body: formData
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }

                        const data = await response.json();

                        // Reset user interaction flag
                        hasUserInteracted = false;

                        // Hi·ªÉn th·ªã input v·ªõi vƒÉn b·∫£n ƒë√£ chuy·ªÉn ƒë·ªïi
                        messageInput.value = data.transcript;
                        inputContainer.classList.remove('hidden');
                        messageInput.focus();
                        statusMessage.textContent = '';

                        // Start auto-send timer only if user hasn't interacted
                        if (!hasUserInteracted) {
                            startAutoSendTimer();
                        }

                    } catch (error) {
                        console.error('L·ªói khi x·ª≠ l√Ω audio:', error);
                        statusMessage.textContent = error.message || 'C√≥ l·ªói x·∫£y ra khi x·ª≠ l√Ω √¢m thanh. Vui l√≤ng th·ª≠ l·∫°i.';
                    } finally {
                        audioChunks = [];
                    }
                };

                return true;
            } catch (error) {
                console.error('L·ªói khi truy c·∫≠p microphone:', error);
                if (error.name === 'NotAllowedError') {
                    statusMessage.textContent = 'Vui l√≤ng cho ph√©p truy c·∫≠p microphone ƒë·ªÉ s·ª≠ d·ª•ng t√≠nh nƒÉng n√†y.';
                } else if (error.name === 'NotFoundError') {
                    statusMessage.textContent = 'Kh√¥ng t√¨m th·∫•y microphone. Vui l√≤ng ki·ªÉm tra thi·∫øt b·ªã c·ªßa b·∫°n.';
                } else {
                    statusMessage.textContent = 'Kh√¥ng th·ªÉ truy c·∫≠p microphone. Vui l√≤ng ki·ªÉm tra l·∫°i quy·ªÅn truy c·∫≠p.';
                }
                return false;
            }
        }

        // H√†m d·ª´ng ghi √¢m
        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                recordButton.classList.remove('recording');
                if (recordingTimeout) {
                    clearTimeout(recordingTimeout);
                    recordingTimeout = null;
                }
            }
        }

        // X·ª≠ l√Ω s·ª± ki·ªán click n√∫t ghi √¢m
        async function startRecord(){
            try {
                if (!mediaRecorder) {
                    const success = await setupRecording();
                    if (!success) return;
                }

                if (!isRecording) {
                    // B·∫Øt ƒë·∫ßu ghi √¢m
                    audioChunks = [];
                    mediaRecorder.start();
                    isRecording = true;
                    recordButton.classList.add('recording');
                    statusMessage.textContent = 'ƒêang ghi √¢m...';

                    // T·ª± ƒë·ªông d·ª´ng sau MAX_RECORDING_TIME
                    recordingTimeout = setTimeout(() => {
                        if (isRecording) {
                            stopRecording();
                            statusMessage.textContent = 'ƒê√£ ƒë·∫°t th·ªùi gian ghi √¢m t·ªëi ƒëa.';
                        }
                    }, MAX_RECORDING_TIME);
                } else {
                    stopRecording();
                }
            } catch (error) {
                console.error('L·ªói khi ghi √¢m:', error);
                statusMessage.textContent = 'C√≥ l·ªói x·∫£y ra khi ghi √¢m. Vui l√≤ng th·ª≠ l·∫°i.';
                isRecording = false;
                recordButton.classList.remove('recording');
            }
        };

        // X·ª≠ l√Ω s·ª± ki·ªán ch·ªçn text
        document.addEventListener('mouseup', (e) => {
            const selection = window.getSelection();
            selectionText = selection.toString().trim();

            if (selectionText && selection.anchorNode.parentNode.parentNode.classList.contains('chat-bubble')) {
                selectedText = selectionText.replaceAll("\n", " ");
                const range = selection.getRangeAt(0);
                const rect = range.getBoundingClientRect();

                // X·ª≠ l√Ω d·ªãch
                handleTranslation(selectedText, rect);
            }
        });

        // X√≥a tooltip khi click ra ngo√†i
        document.addEventListener('mousedown', (e) => {
            const tooltip = document.querySelector('.translation-tooltip');
            if (tooltip) {
                tooltip.remove();
            }
            document.querySelectorAll('.chat-bubble span.clicked').forEach(w => {
                w.classList.remove('clicked');
            });
        });

        // H√†m ph√°t √¢m thanh
        async function playTextToSpeech(message, speakerButton) {
            const userData = localStorage.getItem("userData");
            if (!userData) {
                window.location.href = "index.html";
                return;
            }
            const userDataObj = JSON.parse(userData);
            const token = userDataObj.token;
            try {
                // D·ª´ng √¢m thanh ƒëang ph√°t n·∫øu c√≥
                if (currentAudio) {
                    currentAudio.pause();
                    currentAudio.currentTime = 0;
                }

                // statusMessage.textContent = 'ƒêang chuy·ªÉn ƒë·ªïi vƒÉn b·∫£n th√†nh √¢m thanh...';
                const response = await fetch(`${CONFIG.SERVER_DOMAIN}/speak`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        Authorization: `Bearer ${token}`,
                    },
                    body: JSON.stringify({
                        message,
                    })
                });

                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }

                const data = await response.json();
                const base64Audio = data.audio_base64;

                // Chuy·ªÉn ƒë·ªïi base64 th√†nh Blob
                const binaryString = atob(base64Audio);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                const audioBlob = new Blob([bytes], { type: "audio/mp3" });
                const audioUrl = URL.createObjectURL(audioBlob);
                currentAudio = new Audio(audioUrl);

                // X√≥a URL khi audio k·∫øt th√∫c
                currentAudio.onended = () => {
                    URL.revokeObjectURL(audioUrl);
                    statusMessage.textContent = '';
                    if (speakerButton) {
                        speakerButton.classList.remove('playing');
                    }

                    // K·∫øt th√∫c th√¨ ti·∫øp t·ª•c l·∫Øng nghe ph√¢n t√≠ch 
                    if (isAutoMode) {
                        startAnalyser();
                    }
                };

                currentAudio.play();
                statusMessage.textContent = '';
            } catch (error) {
                console.error('L·ªói khi ph√°t √¢m thanh:', error);
                statusMessage.textContent = 'C√≥ l·ªói x·∫£y ra khi ph√°t √¢m thanh. Vui l√≤ng th·ª≠ l·∫°i.';
            }
        }

        // T·∫£i l·ªãch s·ª≠ chat khi trang ƒë∆∞·ª£c t·∫£i
        document.addEventListener('DOMContentLoaded', () => {
            // Load saved session ID from localStorage
            const savedSessionId = localStorage.getItem('currentSessionId');
            if (savedSessionId) {
                currentSessionId = savedSessionId;
            }
            fetchChatHistory();
        });

        // Add this after the fetchChatHistory function
        async function createNewSession() {
            // Clear chat container
            chatContainer.innerHTML = '';

            // Add welcome message
            addAIMessage("Xin ch√†o! T√¥i l√† tr·ª£ l√Ω AI c·ªßa b·∫°n. H√£y b·∫Øt ƒë·∫ßu luy·ªán t·∫≠p giao ti·∫øp ti·∫øng Anh!");

            // Reset current session ID
            currentSessionId = null;

            // Remove active state from all sessions
            document.querySelectorAll('.session-item').forEach(item => {
                item.classList.remove('active');
            });
        }

        // Add event listener for new session button
        document.getElementById('newSessionButton').addEventListener('click', createNewSession);

        // Add delete session function
        async function deleteSession(sessionId) {
            try {
                const userData = localStorage.getItem('userData');
                if (!userData) {
                    window.location.href = 'index.html';
                    return;
                }
                const userDataObj = JSON.parse(userData);
                const token = userDataObj.token;

                const response = await fetch(`${CONFIG.SERVER_DOMAIN}/messages/${sessionId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to delete session');
                }

                // If deleted session was current session, clear chat
                if (sessionId === currentSessionId) {
                    chatContainer.innerHTML = '';
                    currentSessionId = null;
                    addAIMessage("Xin ch√†o! T√¥i l√† tr·ª£ l√Ω AI c·ªßa b·∫°n. H√£y b·∫Øt ƒë·∫ßu luy·ªán t·∫≠p giao ti·∫øp ti·∫øng Anh!");
                }

                // Refresh session list
                fetchChatHistory();

            } catch (error) {
                console.error('L·ªói khi x√≥a h·ªôi tho·∫°i:', error);
                statusMessage.textContent = 'C√≥ l·ªói x·∫£y ra khi x√≥a h·ªôi tho·∫°i. Vui l√≤ng th·ª≠ l·∫°i.';
            }
        }

        // Modify function to handle auto-send timer
        function startAutoSendTimer() {
            // Clear any existing timer
            if (autoSendTimer) {
                clearTimeout(autoSendTimer);
            }

            // Set new timer only if user hasn't interacted
            if (!hasUserInteracted) {
                autoSendTimer = setTimeout(() => {
                    const text = messageInput.value.trim();
                    if (text) {
                        addUserMessage(text);
                        sendMessage(text);
                    }
                }, 3000); // 5 seconds
            }
        }

        // Add input event listener to reset timer and mark user interaction
        messageInput.addEventListener('input', () => {
            hasUserInteracted = true; // Mark that user has interacted
            if (autoSendTimer) {
                clearTimeout(autoSendTimer);
                autoSendTimer = null;
            }
        });

        // Add click event listener to mark user interaction
        messageInput.addEventListener('click', () => {
            hasUserInteracted = true;
            if (autoSendTimer) {
                clearTimeout(autoSendTimer);
                autoSendTimer = null;
            }
        });

        // Add keydown event listener to mark user interaction
        messageInput.addEventListener('keydown', () => {
            hasUserInteracted = true;
            if (autoSendTimer) {
                clearTimeout(autoSendTimer);
                autoSendTimer = null;
            }
        });

        // Modify sendMessage function to clear timer
        async function sendMessage(text) {
            // Clear auto-send timer
            if (autoSendTimer) {
                clearTimeout(autoSendTimer);
                autoSendTimer = null;
            }

            try {
                const userData = localStorage.getItem('userData');
                if (!userData) {
                    window.location.href = 'index.html';
                    return;
                }
                const userDataObj = JSON.parse(userData);
                const token = userDataObj.token;
                // Hide input and clear content
                inputContainer.classList.add('hidden');
                messageInput.value = '';
                statusMessage.textContent = 'ƒêang x·ª≠ l√Ω...';
                const response = await fetch(`${CONFIG.SERVER_DOMAIN}/chat`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`,
                    },
                    body: JSON.stringify({
                        message: text,
                        session_id: currentSessionId  // Lu√¥n g·ª≠i session_id hi·ªán t·∫°i
                    })
                });

                const data = await response.json();

                // C·∫≠p nh·∫≠t session_id t·ª´ response n·∫øu c√≥
                if (data.session_id) {
                    currentSessionId = data.session_id;
                    setCurrentSessionId(currentSessionId);
                }

                // Add AI response
                addAIMessage(data.response);

                playTextToSpeech(data.response, null);

                // Refresh session list nh∆∞ng kh√¥ng reset currentSessionId
                await fetchChatHistory();


                // statusMessage.textContent = '';
            } catch (error) {
                console.error('L·ªói khi g·ª≠i tin nh·∫Øn:', error);
                statusMessage.textContent = 'C√≥ l·ªói x·∫£y ra khi g·ª≠i tin nh·∫Øn. Vui l√≤ng th·ª≠ l·∫°i.';
            }
        }

        // X·ª≠ l√Ω s·ª± ki·ªán click n√∫t g·ª≠i
        sendButton.addEventListener('click', () => {
            const text = messageInput.value.trim();
            if (text) {
                addUserMessage(text);
                sendMessage(text);
            }
        });

        // X·ª≠ l√Ω s·ª± ki·ªán nh·∫•n Enter trong input
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const text = messageInput.value.trim();
                if (text) {
                    addUserMessage(text);
                    sendMessage(text);
                }
            }
        });

        // Add text-to-speech functionality
        document.getElementById('speakSourceBtn').addEventListener('click', () => {
            const text = document.getElementById('sourceText').value.trim();
            if (text) {
                playTextToSpeech(text, null);
            }
        });

        document.getElementById('speakTargetBtn').addEventListener('click', () => {
            const text = document.getElementById('targetText').textContent.trim();
            if (text) {
                playTextToSpeech(text, null);
            }
        });

        let isAutoMode = false;
        document.getElementById('autoMode').addEventListener('change', (e) => {
            debugger
            if (e.target.checked) {
                isAutoMode = true;
                recordButton.innerHTML = 'ü§ñ'
                startAnalyser();
                recordButton.classList.add('recording');
                recordButton.removeEventListener('click', () => {
                    if (isRecording) {
                        stopRecording();
                    } else {
                        startRecord();
                    }
                });
            } else {
                isAutoMode = false;
                recordButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
                </svg>`
                stopAnalyser();
                recordButton.addEventListener('click', () => {
                    if (isRecording) {
                        stopRecording();
                    } else {
                        startRecord();
                    }
                }); 
            }
        });

        recordButton.addEventListener('click', () => {
            if (isRecording) {
                stopRecording();
            } else {
                startRecord();
            }
        }); 
    </script>
    <script src="translate.js"></script>
</body>

</html>